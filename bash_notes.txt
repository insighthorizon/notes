	Special Variables in particular bash script which is running
Note:	
$0 - The name of the Bash script.
$1 - $9 - The first 9 arguments to the Bash script. (As mentioned above.)
$# - How many arguments were passed to the Bash script.
$@ - All the arguments supplied to the Bash script.
$? - The exit status of the most recently run process.
$$ - The process ID of the current script.
$USER - The username of the user running the script.
$HOSTNAME - The hostname of the machine the script is running on.
$SECONDS - The number of seconds since the script was started.
$RANDOM - Returns a different random number each time is it referred to.
$LINENO - Returns the current line number in the Bash script.	
Command:
env # without argument lists environment variables


	Regular expressions
. (dot) - a single character.
? - the preceding character matches 0 or 1 times only.
* - the preceding character matches 0 or more times.
+ - the preceding character matches 1 or more times.
{n} - the preceding character matches exactly n times.
{n,m} - the preceding character matches at least n times and not more than m times.
[agd] - the character is one of those included within the square brackets.
[^agd] - the character is not one of those included within the square brackets.
[c-f] - the dash within the square brackets operates as a range. In this case it means either the letters c, d, e or f.
() - allows us to group several characters to behave as one.
| (pipe symbol) - the logical OR operation.
^ - matches the beginning of the line.
$ - matches the end of the line.


    Piping and redirection
Every program we run on the command line automatically has three data streams connected to it.

    STDIN (0) - Standard input (data fed into the program)
    STDOUT (1) - Standard output (data printed by the program, defaults to the terminal)
    STDERR (2) - Standard error (for error messages, also defaults to the terminal)
>
    Save output to a file.
>>
    Append output to a file.
<
    Read input from a file.
2>
    Redirect error messages.
|
    Send the output from one program as input to another program.
Bash accomodates piping and redirection by way of special files. Each process gets it's own set of files (one for STDIN, STDOUT and STDERR respectively) and they are linked when piping or redirection is invoked. Each process gets the following files:
STDIN - /proc/<processID>/fd/0
STDOUT - /proc/<processID>/fd/1
STDERR - /proc/<processID>/fd/2
To make life more convenient the system creates some shortcuts for us:
STDIN - /dev/stdin or /proc/self/fd/0
STDOUT - /dev/stdout or /proc/self/fd/1
STDERR - /dev/stderr or /proc/self/fd/2
(A few device files have a meaning that depends on the process that accesses it. For example, /dev/stdin, https://unix.stackexchange.com/questions/18239/understanding-dev-and-its-subdirs-and-files)

      Quotes
Note:      
' Single quotes will treat every character literally.
" Double quotes will allow you to do substitution (that is include variables within the setting of the value).


       Command Substitution
Note:       
take the output of a command or program (what would normally be printed to the screen) and save it as the value of a variable
two variants (Command):
myvar=$(ls /etc | wc -l)
myvar=`ls /etc | wc -l`


	  Variable scope and exporting variables
Command:
export var1
Note:
every time a new process is created (to run another script or such) then make a copy of the variable and hand it over to the new process. So although the variables will have the same name they exist in separate processes and so are unrelated to each other. Exporting variables is a one way process. The original process may pass variables over to the new process but anything that process does with the copy of the variables has no impact on the original variables.

      	   Concatenation
Command:
echo "$var1$var2"
Note: variable with variable
Command:
sed -n "$RANDOM{p}" /usr/share/dict/words
Note: variable with string, curly braces emhasize that 'p' is separate string
echo 1-"$RANDOM"


	Asking user for input
read varname # see $help read	


     Arithmetic
let a=5+4
let "a = 5 + 4"
let a++
expr 5 + 4 # prints the result
a=$( expr 10 - 3 )
Double parentheses (preferred method):
a=$(( 4 + 5 ))
(( b += 3 ))
(( b++ ))


       Length of the variable
${#VARIABLE}       


       Awk
Awk is a good program to use if you need to work with data that is organised into records with fields (such as the sample data below). It allows you to filter the data and control how it is displayed.
awk '{print "name: " $9, "size: " $5, "owner: " $3}' < file.txt # pick the columns 9, 5, 3


    	    If statement   
if [ <some test> ]
then
<commands>
fi
The square brackets ( [ ] ) in the if statement above are actually a reference to the command test.
Test ($man test)
Operator	Description
! EXPRESSION	The EXPRESSION is false.
-n STRING	The length of STRING is greater than zero.
-z STRING	The lengh of STRING is zero (ie it is empty).
STRING1 = STRING2	STRING1 is equal to STRING2
STRING1 != STRING2	STRING1 is not equal to STRING2
INTEGER1 -eq INTEGER2	INTEGER1 is numerically equal to INTEGER2
INTEGER1 -gt INTEGER2	INTEGER1 is numerically greater than INTEGER2
INTEGER1 -lt INTEGER2	INTEGER1 is numerically less than INTEGER2
-d FILE	FILE exists and is a directory.
-e FILE	FILE exists.
-r FILE	FILE exists and the read permission is granted.
-s FILE	FILE exists and it's size is greater than zero (ie. it is not empty).
-w FILE	FILE exists and the write permission is granted.
-x FILE	FILE exists and the execute permission is granted.

Version with arithmetic expression (double parentheses instead []):
if (( $1 > 100)); then
    echo "Argument is bigger than 100"
else
    echo "Argument is smaller than 100"
   fi
double-parentheses construct is also a mechanism for allowing C-style manipulation of variables in Bash
(allows like (( a == 1 )) evaluations)

